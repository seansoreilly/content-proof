{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Next.js Project with TypeScript and Tailwind CSS",
      "description": "Initialize the project structure using Next.js with TypeScript and configure Tailwind CSS for styling.",
      "details": "1. Use create-next-app to set up a new Next.js project with TypeScript\n2. Install and configure Tailwind CSS\n3. Set up project structure (pages, components, styles, utils)\n4. Configure tsconfig.json for strict type checking\n5. Add Lucide React for icons\n6. Set up Vercel CLI for deployment",
      "testStrategy": "Verify project structure, run build process, check Tailwind CSS compilation, ensure TypeScript compilation succeeds",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Initialize Next.js project with TypeScript",
          "description": "Set up a new Next.js project with TypeScript support using create-next-app",
          "dependencies": [],
          "details": "Run 'npx create-next-app@latest' with the TypeScript option. Follow the CLI prompts to set up the project. Ensure the project name and other configurations are set correctly.\n<info added on 2025-06-14T12:24:50.802Z>\nImplementation Plan:\n\n1. Navigate to project root (C:\\projects\\content-proof).\n\n2. Run the following command to scaffold the Next.js project:\n   npx create-next-app@latest . --yes --ts --no-tailwind --eslint --app --src-dir --import-alias \"@/*\" --use-npm | Out-Host\n\n3. Verify successful setup:\n   - Check for presence of package.json, next.config.js, tsconfig.json, and src/ directory.\n   - Run 'npm run build' to ensure TypeScript build passes.\n\n4. Commit the generated scaffolding:\n   - Stage and commit new files selectively.\n   - Ignore build artifacts in .gitignore.\n\nPotential Issues and Mitigations:\n- If directory isn't empty, accept overwrite (new repo, preserve .env).\n- For PowerShell command length issues, split into two commands.\n- If build fails due to missing dependencies, run 'npm install'.\n\nProceed to Subtask 1.2 for Tailwind CSS setup upon completion.\n</info added on 2025-06-14T12:24:50.802Z>\n<info added on 2025-06-14T12:25:33.297Z>\nImplementation Plan Update:\n\n1. Navigate to project root (C:\\projects\\content-proof).\n\n2. Create and scaffold the Next.js project in a 'web' subdirectory:\n   npx create-next-app@latest web --yes --ts --no-tailwind --eslint --app --src-dir --import-alias \"@/*\" --use-npm | Out-Host\n\n3. Verify successful setup:\n   - Check for presence of web/package.json, web/next.config.js, web/tsconfig.json, and web/src/ directory.\n   - Change to the 'web' directory: cd web\n   - Run 'npm run build' to ensure TypeScript build passes.\n\n4. Commit the generated scaffolding:\n   - Stage and commit new files in the 'web' directory selectively.\n   - Ensure .gitignore in the 'web' directory ignores build artifacts.\n\n5. For subsequent tasks and operations:\n   - Execute all Next.js related commands from the './web' directory.\n   - Target the 'web' directory for future Tailwind CSS setup and configuration.\n\nPotential Issues and Mitigations:\n- If 'web' directory already exists, remove or rename it before scaffolding.\n- Ensure proper relative paths are used when referencing files outside the 'web' directory.\n\nProceed to Subtask 1.2 for Tailwind CSS setup upon completion, targeting the 'web' subdirectory.\n</info added on 2025-06-14T12:25:33.297Z>",
          "status": "done",
          "testStrategy": "Verify that the project structure is created and the development server runs without errors"
        },
        {
          "id": 2,
          "title": "Install and configure Tailwind CSS",
          "description": "Add Tailwind CSS to the project and set up the necessary configuration files",
          "dependencies": [
            1
          ],
          "details": "Install Tailwind CSS and its peer dependencies. Create a tailwind.config.js file and configure it for Next.js. Update the global CSS file to include Tailwind directives.",
          "status": "done",
          "testStrategy": "Check that Tailwind classes are working by applying them to a test component"
        },
        {
          "id": 3,
          "title": "Set up project structure and TypeScript configuration",
          "description": "Create the necessary directories for the project and configure TypeScript for strict type checking",
          "dependencies": [
            1
          ],
          "details": "Create directories for pages, components, styles, and utils. Configure tsconfig.json for strict type checking, including setting 'strict' to true and enabling other relevant TypeScript flags.",
          "status": "done",
          "testStrategy": "Run TypeScript compiler to ensure no errors in the initial project setup"
        },
        {
          "id": 4,
          "title": "Install and set up Lucide React for icons",
          "description": "Add Lucide React library to the project for icon support",
          "dependencies": [
            1
          ],
          "details": "Install Lucide React using npm or yarn. Create a test component that uses a Lucide icon to verify the setup. Update any necessary TypeScript definitions if required.",
          "status": "done",
          "testStrategy": "Render a test component with a Lucide icon and verify it displays correctly"
        },
        {
          "id": 5,
          "title": "Configure Vercel CLI for deployment",
          "description": "Install and set up Vercel CLI for easy deployment of the Next.js application",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Install Vercel CLI globally using npm. Log in to Vercel account using the CLI. Link the project to a Vercel project. Test the deployment process with a sample build.",
          "status": "done",
          "testStrategy": "Perform a test deployment to Vercel and verify that the application is accessible and functioning correctly on the deployed URL"
        }
      ]
    },
    {
      "id": 2,
      "title": "Implement Google OAuth Authentication",
      "description": "Set up NextAuth.js for Google OAuth authentication and implement the sign-in flow.",
      "details": "1. Install NextAuth.js\n2. Configure Google OAuth credentials\n3. Implement NextAuth API route\n4. Create sign-in and sign-out components\n5. Implement session management\n6. Add CSRF protection\n7. Implement basic account evaluation logic",
      "testStrategy": "Test sign-in flow, verify session creation, check CSRF protection, unit test account evaluation logic",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up NextAuth.js and Google OAuth credentials",
          "description": "Install NextAuth.js and configure Google OAuth credentials in the Google Developer Console.",
          "dependencies": [],
          "details": "1. Install NextAuth.js using npm or yarn. 2. Create a new project in Google Developer Console. 3. Set up OAuth consent screen. 4. Create OAuth 2.0 Client ID. 5. Note down Client ID and Client Secret.",
          "status": "done",
          "testStrategy": "Verify NextAuth.js installation and ensure Google OAuth credentials are correctly set up and accessible."
        },
        {
          "id": 2,
          "title": "Implement NextAuth API route and configuration",
          "description": "Set up the NextAuth API route and configure NextAuth with Google provider.",
          "dependencies": [
            1
          ],
          "details": "1. Create [...nextauth].js file in pages/api/auth. 2. Import and configure NextAuth with Google provider. 3. Set up environment variables for Google Client ID and Secret. 4. Configure callback URL and other NextAuth options.",
          "status": "done",
          "testStrategy": "Test the API route by making a request to /api/auth/signin and verifying the response."
        },
        {
          "id": 3,
          "title": "Create sign-in and sign-out components",
          "description": "Implement React components for sign-in and sign-out functionality using NextAuth.js hooks.",
          "dependencies": [
            2
          ],
          "details": "1. Create SignIn component using useSession and signIn from next-auth/react. 2. Create SignOut component using signOut from next-auth/react. 3. Implement conditional rendering based on session state.",
          "status": "done",
          "testStrategy": "Create unit tests for SignIn and SignOut components, mocking NextAuth.js hooks."
        },
        {
          "id": 4,
          "title": "Implement session management and CSRF protection",
          "description": "Set up session handling and add CSRF protection to the authentication flow.",
          "dependencies": [
            2,
            3
          ],
          "details": "1. Configure session strategy in NextAuth options. 2. Implement getServerSideProps or getInitialProps for server-side session checks. 3. Add CSRF token to forms and API routes. 4. Verify CSRF token on the server-side.",
          "status": "done",
          "testStrategy": "Test session persistence across page reloads and API calls. Verify CSRF protection by attempting to submit forms without valid tokens."
        },
        {
          "id": 5,
          "title": "Implement basic account evaluation logic",
          "description": "Add logic to evaluate user accounts after successful authentication.",
          "dependencies": [
            4
          ],
          "details": "1. Create a function to check user's email domain or other criteria. 2. Implement logic in NextAuth callbacks (e.g., signIn callback) to evaluate the account. 3. Store evaluation results in the user's session or database. 4. Update UI components to reflect account status.\n<info added on 2025-06-14T13:22:52.794Z>\nImplementation Plan (2025-06-14):\n\nGoal: Evaluate user account during Google OAuth sign-in to allow only users from allowed email domains; store evaluation result in JWT/session for UI use.\n\nSteps:\n1. Create util function `isAllowedEmail(email: string): boolean` in `src/lib/auth/validation.ts`.\n   - Accepts email string; returns true if domain in ALLOWED_EMAIL_DOMAINS env var (comma-separated).\n   - Fallback: allow all if env var undefined.\n\n2. Extend NextAuth configuration in `src/app/api/auth/[...nextauth]/route.ts`:\n   a. Import `isAllowedEmail`.\n   b. Add `callbacks` object with:\n      • `async signIn({ user }):` -> if !isAllowedEmail(user.email) return false\n      • `async jwt({ token, user }):` -> if user?.email, add `allowed: isAllowedEmail(user.email)`\n      • `async session({ session, token }):` -> add `session.user.allowed = token.allowed`\n\n3. Update TypeScript types:\n   - Create `types/next-auth.d.ts` to augment `User`, `Session`, and `JWT` with `allowed: boolean`.\n\n4. Modify existing SignIn/SignOut component (`src/components/AuthButton.tsx` if exists) or create new `AccountStatus.tsx` to display notice if account not allowed.\n   - Use `useSession` to read `session.user.allowed`.\n   - If `false`, show message \"Your account is awaiting approval\".\n\n5. Environment Variable:\n   - Document in README `.env` key `ALLOWED_EMAIL_DOMAINS=\"example.com,company.com\"`.\n   - Fallback to allow any domain when unset (dev convenience).\n\n6. Tests:\n   - Add unit tests for `isAllowedEmail` in `__tests__/validation.test.ts` covering allowed, disallowed, env unset.\n   - Use Jest + `next-auth/jwt` mock for callbacks verifying token.allowed flag.\n\nPotential Issues:\n- Next.js app directory route typing; ensure build passes.\n- Need to mark new types file as non-module with `export {}`.\n\nNext Actions:\n- Set subtask status to in-progress.\n- Implement code changes across new util, route, types, and UI.\n</info added on 2025-06-14T13:22:52.794Z>",
          "status": "done",
          "testStrategy": "Create unit tests for account evaluation logic. Test different scenarios (e.g., allowed vs. disallowed email domains) and verify correct behavior."
        }
      ]
    },
    {
      "id": 3,
      "title": "Develop File Upload and Hash Generation",
      "description": "Create a file upload component and implement SHA-256 hash generation for uploaded files.",
      "details": "1. Create drag & drop file upload component\n2. Implement file validation (type, size)\n3. Use Web Crypto API for SHA-256 hash generation\n4. Display file preview and hash result\n5. Implement error handling for upload failures",
      "testStrategy": "Test file upload with various file types and sizes, verify hash generation accuracy, check error handling for invalid files",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create drag & drop file upload component",
          "description": "Implement a user-friendly drag and drop interface for file uploads using HTML5 and JavaScript",
          "dependencies": [],
          "details": "Use the HTML5 Drag and Drop API. Create a designated drop zone, handle dragover and drop events, and prevent default browser behavior. Implement visual feedback for drag actions.",
          "status": "done",
          "testStrategy": "Test with various file types and sizes. Ensure proper event handling and visual feedback."
        },
        {
          "id": 2,
          "title": "Implement file validation",
          "description": "Add client-side validation for uploaded files, checking file type and size",
          "dependencies": [
            1
          ],
          "details": "Create a function to check file MIME type against an allowed list. Implement size validation using File API. Provide user feedback for invalid files.",
          "status": "done",
          "testStrategy": "Test with various file types (both allowed and disallowed) and sizes. Verify error messages for invalid files."
        },
        {
          "id": 3,
          "title": "Generate SHA-256 hash using Web Crypto API",
          "description": "Implement SHA-256 hash generation for uploaded files using the Web Crypto API",
          "dependencies": [
            2
          ],
          "details": "Use FileReader to read file contents as an ArrayBuffer. Utilize crypto.subtle.digest() to generate the SHA-256 hash. Convert the resulting ArrayBuffer to a hexadecimal string.",
          "status": "done",
          "testStrategy": "Test with known files and compare generated hashes against pre-computed values. Verify performance with large files."
        },
        {
          "id": 4,
          "title": "Display file preview and hash result",
          "description": "Create a UI component to show a preview of the uploaded file (if applicable) and display the generated hash",
          "dependencies": [
            3
          ],
          "details": "For image files, use URL.createObjectURL() to generate a preview. For other file types, display file name and size. Show a loading indicator during hash generation. Present the hash result in a clear, copyable format.",
          "status": "done",
          "testStrategy": "Test with various file types to ensure appropriate previews. Verify hash display for different file sizes and types."
        },
        {
          "id": 5,
          "title": "Implement error handling for upload failures",
          "description": "Add comprehensive error handling for various failure scenarios during file upload and processing",
          "dependencies": [
            4
          ],
          "details": "Handle network errors, file reading errors, and hash generation failures. Implement try-catch blocks around critical operations. Provide clear, user-friendly error messages. Log detailed error information for debugging.",
          "status": "done",
          "testStrategy": "Simulate various error conditions (e.g., network failure, invalid file) and verify appropriate error messages and behavior."
        }
      ]
    },
    {
      "id": 4,
      "title": "Implement Ed25519 Signature Generation",
      "description": "Develop the core cryptographic functionality for generating Ed25519 signatures.",
      "details": "1. Install and configure Node.js Crypto module\n2. Implement Ed25519 key pair generation\n3. Create signature generation function using file hash, Gmail address, and timestamp\n4. Implement signature data structure as per PRD\n5. Store private key securely in Vercel environment variables",
      "testStrategy": "Unit test signature generation, verify signature format, test with various input combinations, ensure private key is not exposed",
      "priority": "high",
      "dependencies": [
        2,
        3
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Install and Configure Node.js Crypto Module",
          "description": "Set up the development environment by installing and configuring the Node.js Crypto module for Ed25519 operations.",
          "dependencies": [],
          "details": "Use npm to install the required crypto module. Verify the installation and import the module in the project. Ensure the module supports Ed25519 operations.\n<info added on 2025-06-14T14:30:53.979Z>\nImplementation completed using Node.js built-in crypto module for Ed25519 operations. No external packages were required due to native Ed25519 support in Node 18+. A new helper module was created at `src/lib/crypto/ed25519.ts`, importing necessary crypto primitives (createPrivateKey, createPublicKey, generateKeyPairSync, sign). Manual testing confirmed successful key pair generation and verification.\n\nKey implementations:\n1. Verified project Node runtime (18+) supports Ed25519.\n2. Added TypeScript types for key objects and signature payloads.\n3. Ensured the helper module compiles without additional configuration.\n\nThe next step (Subtask 4.2) will involve implementing key-pair generation logic within the same helper module.\n</info added on 2025-06-14T14:30:53.979Z>",
          "status": "done",
          "testStrategy": "Create a simple test script to verify the crypto module is correctly installed and can perform basic cryptographic operations."
        },
        {
          "id": 2,
          "title": "Implement Ed25519 Key Pair Generation",
          "description": "Create a function to generate Ed25519 key pairs for signature creation and verification.",
          "dependencies": [],
          "details": "Use the crypto module to implement a function that generates an Ed25519 key pair. Ensure the function returns both the public and private keys in the appropriate format.\n<info added on 2025-06-14T14:31:15.399Z>\nImplementation Summary:\n\nImplemented Ed25519 key pair generation in `src/lib/crypto/ed25519.ts`. The `loadKeyPair()` function now:\na) Constructs KeyObjects from Base64-encoded environment variables `ED25519_PRIVATE_KEY` and `ED25519_PUBLIC_KEY`, or\nb) Generates an ephemeral key pair at runtime using `crypto.generateKeyPairSync('ed25519')` when env vars are absent (development fallback).\n\nKey implementation details:\n- Generated keys are in standard PKCS#8 (private) and SPKI (public) DER buffer formats.\n- Strong typing (KeyObject) is used to prevent misuse.\n- Helper functions are exported to provide Base64/URL-safe representations for client consumption.\n\nGenerated keys are returned as both public and private keys in the appropriate format.\n\nTODO: Implement unit tests to cover valid key format verification and fallback behavior.\n</info added on 2025-06-14T14:31:15.399Z>",
          "status": "done",
          "testStrategy": "Write unit tests to verify that the generated key pairs are valid and in the correct format for Ed25519 operations."
        },
        {
          "id": 3,
          "title": "Create Signature Generation Function",
          "description": "Develop a function that generates an Ed25519 signature using a file hash, Gmail address, and timestamp.",
          "dependencies": [],
          "details": "Implement a function that takes a file hash, Gmail address, and timestamp as inputs. Concatenate these inputs in a specified order, then use the private key to generate an Ed25519 signature of this data.\n<info added on 2025-06-14T14:31:35.108Z>\n2025-06-14 Implementation Summary:\n\nAdded `generateSignature(payload)` function to `src/lib/crypto/ed25519.ts`. It concatenates the SHA-256 file hash, Gmail address, and millisecond timestamp with a `:` separator, encodes the result as UTF-8, and signs the buffer using `crypto.sign(null, message, privateKey)` (Ed25519 automatic). The function returns an object containing:\n• `signature` – Base64URL encoded detached signature\n• `publicKey` – Base64 encoded SPKI DER public key\n• `timestamp` – original timestamp (echo)\n\nAlgorithm parameter is `null` as recommended for Ed25519 in Node.js. The helper automatically loads/generates key pair via `loadKeyPair()`.\n</info added on 2025-06-14T14:31:35.108Z>",
          "status": "done",
          "testStrategy": "Create unit tests with various input combinations to ensure the signature generation is consistent and correct."
        },
        {
          "id": 4,
          "title": "Implement Signature Data Structure",
          "description": "Create a data structure to store and represent the generated signature along with its associated metadata as specified in the PRD.",
          "dependencies": [],
          "details": "Design and implement a data structure (e.g., a JavaScript object) that includes fields for the signature, public key, timestamp, and any other required metadata. Ensure the structure matches the specifications in the PRD.\n<info added on 2025-06-14T14:31:53.240Z>\nThe data structure for the signature payload has been implemented as follows:\n\n1. Two TypeScript interfaces have been defined in `src/lib/crypto/ed25519.ts`:\n   - `SignaturePayload`: Represents the input for signature generation\n   - `SignatureData`: Represents the resulting metadata object\n\n2. The `SignatureData` interface includes the following fields as per PRD requirements:\n   - `signature`\n   - `publicKey`\n   - `timestamp`\n\n3. Both interfaces are exported, allowing for reuse across the codebase.\n\n4. The interfaces are designed to be fully serializable to JSON.\n\n5. These types will be used in future API route implementations and client-side verification logic.\n\nThis implementation ensures that the data structure matches the specifications outlined in the PRD and provides a solid foundation for the signature generation and verification processes.\n</info added on 2025-06-14T14:31:53.240Z>",
          "status": "done",
          "testStrategy": "Write tests to verify that the data structure correctly stores all required information and can be easily serialized/deserialized."
        },
        {
          "id": 5,
          "title": "Securely Store Private Key in Vercel Environment",
          "description": "Implement a secure method to store the generated Ed25519 private key in Vercel environment variables.",
          "dependencies": [],
          "details": "Create a script to securely generate and store the Ed25519 private key as a Vercel environment variable. Implement safeguards to prevent accidental exposure of the key in logs or error messages.\n<info added on 2025-06-14T14:32:17.538Z>\nImplementation Summary:\n\nThe helper `src/lib/crypto/ed25519.ts` expects the private/public keys to be supplied via environment variables `ED25519_PRIVATE_KEY` and `ED25519_PUBLIC_KEY` (Base64‐encoded DER). If absent (local development), the module falls back to generating an ephemeral key pair at runtime to avoid build failures.\n\nOperational Steps (to be documented in README):\n1. Run `node -e \"console.log(require('crypto').generateKeyPairSync('ed25519').privateKey.export({type:'pkcs8',format:'der'}).toString('base64'))\"` to generate a private key, and similar for the public key.\n2. Add the resulting strings as Vercel project environment variables.\n3. Redeploy.\n\nSafeguards:\n- Keys are never logged.\n- `loadKeyPair()` throws if only one of the two env vars is provided.\n\nThis implementation ensures the application securely loads the key from the environment without exposing it.\n</info added on 2025-06-14T14:32:17.538Z>",
          "status": "done",
          "testStrategy": "Develop integration tests to ensure the application can correctly retrieve and use the private key from the Vercel environment without exposing it."
        }
      ]
    },
    {
      "id": 5,
      "title": "Develop QR Code Generation and Embedding",
      "description": "Create functionality to generate QR codes with embedded signature data and implement the self-contained verification link.",
      "status": "pending",
      "dependencies": [
        4
      ],
      "priority": "medium",
      "details": "1. Choose and integrate a QR code generation library\n2. Implement JSON to Base64URL encoding for signature data\n3. Create the self-contained verification link structure\n4. Generate QR codes with the correct size and error correction level\n5. Implement QR code download functionality",
      "testStrategy": "Test QR code generation with various signature data, verify QR code scannability, check embedded data accuracy, test QR code download",
      "subtasks": [
        {
          "id": 1,
          "title": "Integrate QR Code Generation Library",
          "description": "Research, select, and integrate a suitable QR code generation library into the project.",
          "dependencies": [],
          "details": "1. Added `qrcode` (^1.5.1) dependency to package.json.\n2. Created `src/lib/qr/index.ts` containing QR code generation logic.\n3. Implemented tree-shakable dynamic import for QR logic to load only when required.",
          "status": "completed",
          "testStrategy": "Write unit tests to ensure the wrapper module correctly generates QR codes with various inputs."
        },
        {
          "id": 2,
          "title": "Implement JSON to Base64URL Encoding",
          "description": "Create a function to convert JSON signature data to Base64URL encoding for compact representation in QR codes.",
          "dependencies": [],
          "details": "Implemented `toBase64Url` function in `src/lib/qr/index.ts` that converts JSON to Base64URL encoding.",
          "status": "completed",
          "testStrategy": "Create unit tests with various JSON inputs to ensure correct encoding and URL-safety of the output."
        },
        {
          "id": 3,
          "title": "Create Self-Contained Verification Link Structure",
          "description": "Design and implement the structure for self-contained verification links that will be encoded in QR codes.",
          "dependencies": [],
          "details": "Implemented `createVerificationUrl` function in `src/lib/qr/index.ts` that constructs self-contained verification URL using env `NEXT_PUBLIC_VERIFY_BASE_URL` or `location.origin` fallback.",
          "status": "completed",
          "testStrategy": "Write unit tests to verify correct URL construction and handling of edge cases (e.g., very long encoded data)."
        },
        {
          "id": 4,
          "title": "Generate QR Codes with Correct Parameters",
          "description": "Use the integrated QR code library to generate codes with the proper size and error correction level, containing the verification links.",
          "dependencies": [],
          "details": "Implemented `generateQrCodeDataUrl` function in `src/lib/qr/index.ts` that returns PNG data-URL with configurable width & error-correction (defaults 256px / level M).",
          "status": "completed",
          "testStrategy": "Develop integration tests that generate QR codes and verify their content and parameters using a QR code reader library."
        },
        {
          "id": 5,
          "title": "Implement QR Code Download Functionality",
          "description": "Create a feature allowing users to download the generated QR codes in various image formats.",
          "dependencies": [],
          "details": "Added `src/components/QrCodeGenerator.tsx` (client component) that renders <img> preview and 'Download PNG' anchor for generated QR codes.",
          "status": "completed",
          "testStrategy": "Create end-to-end tests simulating user interactions to generate and download QR codes, verifying the correctness and accessibility of the downloaded files."
        },
        {
          "id": 6,
          "title": "Wire Signature API and UI Flow",
          "description": "Connect the signature API and UI flow to feed SignatureData into the new QrCodeGenerator component.",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "1. Integrate the SignatureData from the signature API into the UI flow.\n2. Pass the SignatureData to the QrCodeGenerator component.\n3. Ensure proper error handling and data validation.\n4. Update UI to display QR code at appropriate points in the signature process.",
          "status": "pending",
          "testStrategy": "Develop integration tests to verify the correct flow of data from the signature API to the QR code generation. Create end-to-end tests to simulate the entire user journey from signature creation to QR code generation and download."
        }
      ]
    },
    {
      "id": 6,
      "title": "Implement Signature Verification System",
      "description": "Develop the client-side signature verification process, including file hash comparison and Ed25519 signature verification.",
      "details": "1. Implement file hash calculation for uploaded files\n2. Develop Ed25519 signature verification logic\n3. Create verification result display component\n4. Implement error handling for verification process\n5. Ensure offline functionality with cached public key",
      "testStrategy": "Test verification with valid and invalid signatures, check offline functionality, verify error handling for various scenarios",
      "priority": "high",
      "dependencies": [
        4,
        5
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement File Hash Calculation",
          "description": "Create a function to calculate the SHA-256 hash of uploaded files on the client-side.",
          "dependencies": [],
          "details": "Use the Web Crypto API to implement SHA-256 hash calculation. Create a utility function that takes a File object as input and returns a Promise resolving to the hash as a hexadecimal string.",
          "status": "pending",
          "testStrategy": "Write unit tests with sample files of various sizes and known hashes to verify correct hash calculation."
        },
        {
          "id": 2,
          "title": "Develop Ed25519 Signature Verification Logic",
          "description": "Implement the core logic for verifying Ed25519 signatures using the calculated file hash and provided signature.",
          "dependencies": [
            1
          ],
          "details": "Use a WebAssembly-compiled library like TweetNaCl.js for Ed25519 operations. Create a function that takes the file hash, signature, and public key as inputs and returns a boolean indicating whether the signature is valid.",
          "status": "pending",
          "testStrategy": "Create unit tests with known valid and invalid signature/hash/public key combinations to ensure correct verification."
        },
        {
          "id": 3,
          "title": "Create Verification Result Display Component",
          "description": "Develop a React component to display the results of the signature verification process to the user.",
          "dependencies": [
            2
          ],
          "details": "Create a new React component that takes verification results as props and renders appropriate success or failure messages, along with relevant details like the file name and hash.",
          "status": "pending",
          "testStrategy": "Write component tests to ensure correct rendering for various verification result scenarios."
        },
        {
          "id": 4,
          "title": "Implement Error Handling for Verification Process",
          "description": "Add comprehensive error handling to the verification process, including user-friendly error messages for various failure scenarios.",
          "dependencies": [
            2,
            3
          ],
          "details": "Identify potential error scenarios (e.g., invalid file format, network issues, invalid signature format) and implement try-catch blocks or error boundaries as appropriate. Update the result display component to show specific error messages.",
          "status": "pending",
          "testStrategy": "Develop unit tests that simulate various error conditions and ensure proper error handling and display."
        },
        {
          "id": 5,
          "title": "Ensure Offline Functionality with Cached Public Key",
          "description": "Implement a mechanism to cache the public key locally and enable signature verification without an internet connection.",
          "dependencies": [
            2,
            4
          ],
          "details": "Use browser's local storage or IndexedDB to cache the public key. Modify the verification process to first attempt to use the cached key, falling back to fetching from the server if not available. Implement a background sync to update the cached key when online.",
          "status": "pending",
          "testStrategy": "Test the verification process in various network conditions, including complete offline mode, to ensure functionality with the cached public key."
        }
      ]
    },
    {
      "id": 7,
      "title": "Develop Public Key Distribution System",
      "description": "Implement the well-known endpoint for public key distribution and the key rotation mechanism.",
      "details": "1. Create /.well-known/public-keys.json endpoint\n2. Implement public key storage and retrieval in Vercel environment\n3. Develop key rotation logic\n4. Implement backward compatibility for older keys\n5. Create API for fetching current and historical public keys",
      "testStrategy": "Test public key endpoint, verify key rotation process, check backward compatibility, ensure proper error handling for key fetching",
      "priority": "medium",
      "dependencies": [
        4
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create /.well-known/public-keys.json endpoint",
          "description": "Implement a new API endpoint that serves the public keys in JSON format at the /.well-known/public-keys.json path.",
          "dependencies": [],
          "details": "Use the API routing system to create a new endpoint. The response should be a JSON object containing the current public key and any historical keys. Ensure proper CORS headers are set for public access.",
          "status": "pending",
          "testStrategy": "Write unit tests to verify the endpoint returns valid JSON and integration tests to check the correct public keys are returned."
        },
        {
          "id": 2,
          "title": "Implement public key storage in Vercel environment",
          "description": "Set up a secure storage mechanism for public keys within the Vercel environment, allowing for easy retrieval and updates.",
          "dependencies": [],
          "details": "Use Vercel's environment variables or a secure key-value store to save the public keys. Implement functions to read and write keys to this storage. Ensure that the storage method is scalable and supports multiple keys.",
          "status": "pending",
          "testStrategy": "Create unit tests for the storage functions, mocking the Vercel environment. Test reading, writing, and updating keys."
        },
        {
          "id": 3,
          "title": "Develop key rotation logic",
          "description": "Implement a mechanism to rotate public keys periodically or on-demand, ensuring smooth transitions between keys.",
          "dependencies": [
            2
          ],
          "details": "Create a function that generates a new key pair, stores the new public key, and updates the current key pointer. Implement logic to determine when a key rotation should occur (e.g., based on time or manual trigger). Ensure that old keys are retained for a specified period.",
          "status": "pending",
          "testStrategy": "Write unit tests for the key rotation function. Create integration tests that simulate key rotations and verify that the system uses the new keys correctly."
        },
        {
          "id": 4,
          "title": "Implement backward compatibility for older keys",
          "description": "Ensure that the system can validate signatures created with older public keys for a specified period after rotation.",
          "dependencies": [
            3
          ],
          "details": "Modify the signature validation logic to check against both the current key and recent historical keys. Implement a mechanism to expire and remove very old keys. Update the public key retrieval function to return both current and valid historical keys.",
          "status": "pending",
          "testStrategy": "Create unit tests for signature validation with both current and historical keys. Implement integration tests that simulate key rotations and verify that signatures from older keys are still accepted for a specified period."
        },
        {
          "id": 5,
          "title": "Create API for fetching current and historical public keys",
          "description": "Develop an internal API that allows other parts of the system to fetch the current public key and valid historical keys.",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Implement a function that returns an object containing the current public key and an array of valid historical keys. This function should interface with the storage mechanism and apply any necessary filtering or formatting. Ensure that this API is easily accessible to other parts of the codebase.",
          "status": "pending",
          "testStrategy": "Write unit tests for the API function, mocking the storage layer. Create integration tests that verify the correct keys are returned after simulated key rotations and expirations."
        }
      ]
    },
    {
      "id": 8,
      "title": "Implement User Interface Components",
      "description": "Develop the main UI components for the landing page, signing interface, and verification interface.",
      "details": "1. Create responsive landing page with feature explanations\n2. Develop signing interface with user status, upload area, and output options\n3. Implement verification interface with QR scanning and manual entry options\n4. Create reusable components for common UI elements\n5. Implement loading states and error messages\n6. Ensure accessibility compliance",
      "testStrategy": "Conduct usability testing, verify responsiveness across devices, check accessibility compliance, test all UI interactions and state changes",
      "priority": "medium",
      "dependencies": [
        1,
        2,
        3,
        5,
        6
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Responsive Landing Page",
          "description": "Develop a responsive landing page that explains the key features of the application",
          "dependencies": [],
          "details": "Use HTML5, CSS3 with Flexbox or Grid for layout. Implement mobile-first design. Include sections for hero, feature explanations, and call-to-action. Ensure proper semantic markup for SEO and accessibility.",
          "status": "pending",
          "testStrategy": "Test responsiveness across various device sizes. Validate HTML and CSS. Conduct user testing for clarity of feature explanations."
        },
        {
          "id": 2,
          "title": "Develop Signing Interface",
          "description": "Create the signing interface with user status display, document upload area, and output options",
          "dependencies": [
            1
          ],
          "details": "Use React components for modular design. Implement drag-and-drop file upload with fallback. Display user status (logged in, permissions). Create output options as radio buttons or dropdown. Use CSS modules for styling.",
          "status": "pending",
          "testStrategy": "Unit test React components. Integration test file upload functionality. User acceptance testing for intuitive design."
        },
        {
          "id": 3,
          "title": "Implement Verification Interface",
          "description": "Build the verification interface with QR code scanning and manual entry options",
          "dependencies": [
            1
          ],
          "details": "Integrate a QR code scanning library (e.g., qr-scanner). Create a manual entry form with proper input validation. Implement tab switching between scan and manual entry. Ensure real-time feedback on verification status.",
          "status": "pending",
          "testStrategy": "Test QR scanning with various code types. Validate manual entry form inputs. Conduct usability testing for ease of switching between options."
        },
        {
          "id": 4,
          "title": "Create Reusable UI Components",
          "description": "Develop a set of reusable components for common UI elements across the application",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Create a component library including buttons, input fields, modals, and loading indicators. Use Storybook for component documentation. Implement theming support for consistent styling. Ensure components are fully accessible.",
          "status": "pending",
          "testStrategy": "Write unit tests for each component. Use Storybook for visual regression testing. Conduct accessibility audits using tools like axe-core."
        },
        {
          "id": 5,
          "title": "Implement Loading States and Error Handling",
          "description": "Add loading indicators and error message displays throughout the application",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Create a global loading state manager (e.g., using React Context). Implement skeleton screens for content loading. Design and implement error message components. Add error boundary components to catch and display unexpected errors.",
          "status": "pending",
          "testStrategy": "Test loading states for all async operations. Simulate and test error scenarios. Conduct UX testing to ensure clear communication of system status."
        }
      ]
    },
    {
      "id": 9,
      "title": "Implement API Routes and Database Integration",
      "description": "Develop the required API routes and integrate with Upstash Redis for data storage and retrieval.",
      "details": "1. Implement /api/sign endpoint for signature generation\n2. Create /api/verify endpoint for enhanced verification experience\n3. Develop /api/trust/{gmailAddress} endpoint for trust level retrieval\n4. Implement /api/qr/{signatureId} for QR code generation\n5. Integrate Upstash Redis for data storage\n6. Implement rate limiting using Upstash Redis\n7. Ensure proper error handling and input validation for all API routes",
      "testStrategy": "Unit test all API routes, verify Redis integration, test rate limiting functionality, check error handling and input validation",
      "priority": "high",
      "dependencies": [
        2,
        4,
        7
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement /api/sign and /api/verify endpoints",
          "description": "Create API routes for signature generation and verification",
          "dependencies": [],
          "details": "Use Next.js API routes to implement /api/sign for signature generation and /api/verify for enhanced verification. Ensure proper request handling, input validation, and error responses.",
          "status": "pending",
          "testStrategy": "Write unit tests for each endpoint using Jest, covering various input scenarios and expected outputs."
        },
        {
          "id": 2,
          "title": "Develop /api/trust/{gmailAddress} and /api/qr/{signatureId} endpoints",
          "description": "Implement API routes for trust level retrieval and QR code generation",
          "dependencies": [
            1
          ],
          "details": "Create Next.js API routes for /api/trust/{gmailAddress} to retrieve trust levels and /api/qr/{signatureId} for QR code generation. Use appropriate libraries for QR code creation.",
          "status": "pending",
          "testStrategy": "Develop integration tests to ensure correct data retrieval and QR code generation for various inputs."
        },
        {
          "id": 3,
          "title": "Integrate Upstash Redis for data storage",
          "description": "Set up Upstash Redis connection and implement data storage functions",
          "dependencies": [
            1,
            2
          ],
          "details": "Configure Upstash Redis client, create utility functions for data storage and retrieval, and integrate these functions into the existing API routes.",
          "status": "pending",
          "testStrategy": "Create mock Redis client for unit testing, and use a test Redis instance for integration testing of storage and retrieval operations."
        },
        {
          "id": 4,
          "title": "Implement rate limiting using Upstash Redis",
          "description": "Add rate limiting functionality to API routes using Upstash Redis",
          "dependencies": [
            3
          ],
          "details": "Develop a rate limiting middleware using Upstash Redis to track and limit API requests. Apply this middleware to all API routes.",
          "status": "pending",
          "testStrategy": "Write tests to verify rate limiting behavior, including successful requests within limits and blocked requests when limits are exceeded."
        },
        {
          "id": 5,
          "title": "Enhance error handling and input validation",
          "description": "Implement comprehensive error handling and input validation for all API routes",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Create reusable validation functions, implement try-catch blocks for error handling, and ensure all API routes return appropriate error responses with status codes and messages.",
          "status": "pending",
          "testStrategy": "Develop a suite of tests covering various error scenarios and invalid inputs for each API route, ensuring correct error responses are returned."
        }
      ]
    },
    {
      "id": 10,
      "title": "Implement Analytics and Monitoring",
      "description": "Set up Google Analytics for event tracking and implement monitoring solutions for the application.",
      "details": "1. Integrate Google Analytics\n2. Implement custom event tracking for sign_file, verify_signature, and user_registration events\n3. Set up Vercel Analytics for performance monitoring\n4. Integrate Sentry for error tracking and reporting\n5. Implement logging for critical operations\n6. Create dashboard for visualizing key metrics",
      "testStrategy": "Verify Google Analytics integration, test custom event tracking, check Vercel Analytics and Sentry functionality, review logged information for completeness",
      "priority": "low",
      "dependencies": [
        8,
        9
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Integrate Google Analytics and Set Up Custom Event Tracking",
          "description": "Set up Google Analytics for the application and implement custom event tracking for sign_file, verify_signature, and user_registration events.",
          "dependencies": [],
          "details": "1. Create a Google Analytics account and property for the application. 2. Add the Google Analytics tracking code to the application's base template or layout. 3. Define and implement custom events for sign_file, verify_signature, and user_registration using Google Analytics 4 (gtag.js). 4. Test event tracking to ensure proper data collection.",
          "status": "pending",
          "testStrategy": "Use Google Analytics Debug mode and Real-Time reports to verify event tracking implementation."
        },
        {
          "id": 2,
          "title": "Implement Vercel Analytics for Performance Monitoring",
          "description": "Set up Vercel Analytics to monitor application performance metrics.",
          "dependencies": [
            1
          ],
          "details": "1. Enable Vercel Analytics in the Vercel dashboard for the project. 2. Add the Vercel Analytics script to the application. 3. Configure performance metrics to be tracked (e.g., Web Vitals). 4. Set up custom performance markers for critical operations.",
          "status": "pending",
          "testStrategy": "Use Vercel's preview deployments to test analytics implementation before pushing to production."
        },
        {
          "id": 3,
          "title": "Integrate Sentry for Error Tracking and Reporting",
          "description": "Implement Sentry to capture and report application errors and exceptions.",
          "dependencies": [
            1
          ],
          "details": "1. Create a Sentry account and project for the application. 2. Install the Sentry SDK for the application's framework. 3. Configure Sentry in the application, including environment-specific settings. 4. Implement custom error handling and reporting for critical sections of the application.",
          "status": "pending",
          "testStrategy": "Deliberately trigger errors in a development environment to verify Sentry captures and reports them correctly."
        },
        {
          "id": 4,
          "title": "Implement Logging for Critical Operations",
          "description": "Set up a logging system to record important events and operations within the application.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1. Choose and implement a logging library suitable for the application's stack. 2. Define log levels (e.g., INFO, WARNING, ERROR) and implement logging throughout the application code. 3. Set up log rotation and storage mechanisms. 4. Implement alerts for critical log events.",
          "status": "pending",
          "testStrategy": "Review logs generated during testing of other features to ensure proper logging of critical operations."
        },
        {
          "id": 5,
          "title": "Create Dashboard for Visualizing Key Metrics",
          "description": "Develop a dashboard to display and visualize key metrics from Google Analytics, Vercel Analytics, Sentry, and application logs.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1. Design the layout and components of the dashboard. 2. Implement data retrieval from Google Analytics, Vercel Analytics, and Sentry APIs. 3. Create visualizations (charts, graphs) for key metrics. 4. Implement real-time updates for the dashboard. 5. Add filtering and date range selection capabilities.",
          "status": "pending",
          "testStrategy": "Conduct user acceptance testing with stakeholders to ensure the dashboard provides valuable insights and meets requirements."
        }
      ]
    }
  ]
}